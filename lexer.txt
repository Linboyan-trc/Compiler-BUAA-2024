CONSTTK const
INTTK int
IDENFR const1
ASSIGN =
INTCON 42
SEMICN ;
INTTK int
IDENFR global_var
ASSIGN =
INTCON 0
SEMICN ;
VOIDTK void
IDENFR test_illegal_symbol
LPARENT (
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR global_var
OR |
IDENFR const1
RPARENT )
LBRACE {
IDENFR global_var
ASSIGN =
INTCON 1
SEMICN ;
RBRACE }
RBRACE }
VOIDTK void
IDENFR test_name_redefinition
LPARENT (
RPARENT )
LBRACE {
INTTK int
IDENFR x
ASSIGN =
INTCON 10
SEMICN ;
INTTK int
IDENFR x
ASSIGN =
INTCON 20
SEMICN ;
RBRACE }
VOIDTK void
IDENFR test_undefined_name
LPARENT (
RPARENT )
LBRACE {
INTTK int
IDENFR result
ASSIGN =
IDENFR undefined_var
PLUS +
INTCON 1
SEMICN ;
RBRACE }
VOIDTK void
IDENFR test_func_param_count
LPARENT (
INTTK int
IDENFR x
COMMA ,
INTTK int
IDENFR y
RPARENT )
LBRACE {
RBRACE }
VOIDTK void
IDENFR test_param_count_error
LPARENT (
RPARENT )
LBRACE {
IDENFR test_func_param_count
LPARENT (
INTCON 1
RPARENT )
SEMICN ;
RBRACE }
VOIDTK void
IDENFR test_func_param_type
LPARENT (
INTTK int
IDENFR x
COMMA ,
INTTK int
IDENFR arr
LBRACK [
RBRACK ]
RPARENT )
LBRACE {
RBRACE }
VOIDTK void
IDENFR test_param_type_error
LPARENT (
RPARENT )
LBRACE {
CHARTK char
IDENFR invalid_param
LBRACK [
INTCON 5
RBRACK ]
SEMICN ;
IDENFR test_func_param_type
LPARENT (
INTCON 1
COMMA ,
IDENFR invalid_param
RPARENT )
SEMICN ;
RBRACE }
VOIDTK void
IDENFR test_void_return_value
LPARENT (
RPARENT )
LBRACE {
RETURNTK return
INTCON 1
SEMICN ;
RBRACE }
INTTK int
IDENFR test_missing_return
LPARENT (
RPARENT )
LBRACE {
INTTK int
IDENFR x
ASSIGN =
INTCON 10
SEMICN ;
RBRACE }
VOIDTK void
IDENFR test_modify_constant
LPARENT (
RPARENT )
LBRACE {
IDENFR const1
ASSIGN =
INTCON 50
SEMICN ;
RBRACE }
VOIDTK void
IDENFR test_missing_semicolon
LPARENT (
RPARENT )
LBRACE {
INTTK int
IDENFR x
ASSIGN =
INTCON 10
RBRACE }
VOIDTK void
IDENFR test_missing_parenthesis
LPARENT (
INTTK int
IDENFR x
COMMA ,
INTTK int
IDENFR y
LBRACE {
RETURNTK return
IDENFR x
PLUS +
IDENFR y
SEMICN ;
RBRACE }
VOIDTK void
IDENFR test_missing_bracket
LPARENT (
RPARENT )
LBRACE {
INTTK int
IDENFR arr
LBRACK [
INTCON 5
SEMICN ;
RBRACE }
VOIDTK void
IDENFR test_printf_mismatch
LPARENT (
RPARENT )
LBRACE {
INTTK int
IDENFR x
ASSIGN =
INTCON 10
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "%d %d\n"
COMMA ,
IDENFR x
RPARENT )
SEMICN ;
RBRACE }
VOIDTK void
IDENFR test_invalid_break
LPARENT (
RPARENT )
LBRACE {
BREAKTK break
SEMICN ;
RBRACE }
VOIDTK void
IDENFR process_array
LPARENT (
INTTK int
IDENFR arr
LBRACK [
RBRACK ]
COMMA ,
INTTK int
IDENFR size
RPARENT )
LBRACE {
INTTK int
IDENFR i
SEMICN ;
FORTK for
LPARENT (
IDENFR i
ASSIGN =
INTCON 0
SEMICN ;
IDENFR i
LSS <
IDENFR size
SEMICN ;
IDENFR i
ASSIGN =
IDENFR i
PLUS +
INTCON 1
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR arr
LBRACK [
IDENFR i
RBRACK ]
MOD %
INTCON 2
EQL ==
INTCON 0
RPARENT )
LBRACE {
IDENFR arr
LBRACK [
IDENFR i
RBRACK ]
ASSIGN =
IDENFR arr
LBRACK [
IDENFR i
RBRACK ]
DIV /
INTCON 2
SEMICN ;
RBRACE }
ELSETK else
LBRACE {
IDENFR arr
LBRACK [
IDENFR i
RBRACK ]
ASSIGN =
IDENFR arr
LBRACK [
IDENFR i
RBRACK ]
MULT *
INTCON 3
PLUS +
INTCON 1
SEMICN ;
RBRACE }
RBRACE }
RBRACE }
INTTK int
MAINTK main
LPARENT (
RPARENT )
LBRACE {
INTTK int
IDENFR x
ASSIGN =
INTCON 10
COMMA ,
IDENFR y
ASSIGN =
INTCON 20
SEMICN ;
INTTK int
IDENFR x
ASSIGN =
INTCON 30
SEMICN ;
INTTK int
IDENFR i
SEMICN ;
FORTK for
LPARENT (
IDENFR i
ASSIGN =
INTCON 0
SEMICN ;
IDENFR i
LSS <
INTCON 10
SEMICN ;
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR i
EQL ==
INTCON 5
RPARENT )
LBRACE {
CONTINUETK continue
SEMICN ;
RBRACE }
RBRACE }
CONTINUETK continue
SEMICN ;
LBRACE {
CONSTTK const
INTTK int
IDENFR nested_const
ASSIGN =
INTCON 100
SEMICN ;
IDENFR nested_const
ASSIGN =
INTCON 200
SEMICN ;
LBRACE {
INTTK int
IDENFR aaa
ASSIGN =
IDENFR bbb
SEMICN ;
LBRACE {
INTTK int
IDENFR bbb
ASSIGN =
INTCON 1
SEMICN ;
LBRACE {
INTTK int
IDENFR ccc
SEMICN ;
RBRACE }
RBRACE }
RBRACE }
RBRACE }
INTTK int
IDENFR arr
LBRACK [
INTCON 10
RBRACK ]
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "%d %d"
COMMA ,
IDENFR arr
LBRACK [
INTCON 5
RBRACK ]
RPARENT )
SEMICN ;
RETURNTK return
SEMICN ;
RBRACE }
